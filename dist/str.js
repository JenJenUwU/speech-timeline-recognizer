#!/usr/bin/env node
"use strict";var B=Object.create;var _=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var U=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var G=(t,r,e,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of T(r))!q.call(t,o)&&o!==e&&_(t,o,{get:()=>r[o],enumerable:!(n=I(r,o))||n.enumerable});return t};var a=(t,r,e)=>(e=t!=null?B(U(t)):{},G(r||!t||!t.__esModule?_(e,"default",{value:t,enumerable:!0}):e,t));var m=a(require("fs")),x=a(require("path")),b=require("commander");var S=a(require("fs"));var R=a(require("fs")),J=a(require("path")),N=require("stream"),y=a(require("vosk-lib")),L=a(require("wav")),A=a(require("fuse.js")),C=require("opencc");var $=a(require("path")),F=$.default.resolve(__dirname,"..","model"),P=process.env.VERBOSE;var z=a(require("os")),v=a(require("path")),E=require("child_process");function k(t,r="ffmpeg"){let e=v.default.resolve(z.default.tmpdir(),`${v.default.basename(t)}.wav`),n=["-loglevel","error","-i",v.default.basename(t),"-af","agate=range=0:ratio=100:threshold=0.01, dynaudnorm=p=0.5:m=100:s=12:g=15, loudnorm=I=-10:LRA=11:TP=-1","-acodec","pcm_s16le","-ac","1","-ar","16000",e];return(0,E.spawnSync)(r,n,{cwd:v.default.dirname(t),stdio:P?"inherit":"ignore"}),e}var D=!1,M,j=new C.OpenCC("s2t.json");function W(t,r,e){return D===!1&&(e||console.log("Loading model ..."),y.default.setLogLevel(-1),M=new y.default.Model(F),D=!0,e||console.log("Model loaded.")),t=k(J.default.resolve(t)),new Promise(n=>{e||console.log(`Recognizing ${t} ...`);let o=R.default.createReadStream(t,{highWaterMark:4096}),s=new L.default.Reader,l=new N.Readable().wrap(s);s.on("format",async({audioFormat:c,sampleRate:g,channels:d})=>{if(c!=1||d!=1)throw new Error("Audio file must be WAV with mono PCM.");let p=new y.default.Recognizer({model:M,sampleRate:g});p.setMaxAlternatives(3),p.setWords(!0),p.setPartialWords(!0);let i=[];for await(let f of l)if(p.acceptWaveform(f)){let h=await H(p.result(),r);i.push(h),console.log(h),r&&(r=r.slice(h.text.length))}let w={text:i.map(f=>f.text).join(""),words:i.map(f=>f.result.map(u=>({start:u.start,end:u.end,value:u.word}))).flat()};e||console.log(`Recognized ${t}`),o.close(()=>{n(w),R.default.rmSync(t)}),p.free()}),o.pipe(s)})}async function H(t,r){let{alternatives:e}=t;for(let n=0;n<e.length;n++){e[n].text=await j.convertPromise(e[n].text.replace(/\s+/g,""));for(let o=0;o<e[n].result.length;o++)e[n].result[o].word=await j.convertPromise(e[n].result[o].word);delete e[n].confidence}if(r){let o=new A.default(e,{keys:["text"],threshold:1}).search(r);return o.length>0?o.map(s=>s.item)[0]:{result:[],text:""}}else return e[0]}async function O(t,r,e){let o=S.default.readFileSync(t),l=16e3*10,c=0,g=[];for(;c<o.length;){let p=o.slice(c,c+l),i=`segment_${c/l}.wav`;S.default.writeFileSync(i,p);let w=await W(i,r,e);g.push(w.text),S.default.unlinkSync(i),c+=l}return g.join(" ")}var K="C:/Users/Admin/Desktop/CodingFiles/speech-timeline-recognizer/data/sub-0002/sub-0002_ffmpeg.wav";O(K).then(t=>{console.log(t)});var V=JSON.parse(m.default.readFileSync(x.default.join(__dirname,"..","package.json"),"utf8"));b.program.version(`${V.name} ${V.version}`);b.program.argument("<wav...>","Path to the wav file").option("-e, --expect <expected result>","The expected result").option("-o, --output <path>","The output path").option("-f, --force","Force to overwrite the output file if it exists").option("-p, --pretty","Pretty print the result with indentation").option("-s, --silent","Silent mode").action(async(t,{expect:r,output:e,force:n,pretty:o,silent:s})=>{e&&(e=x.default.resolve(e),m.default.existsSync(e)&&!n&&(s||console.error(`${e} already exists.`),process.exit(1)));let l={};for(let d of t)l[d]=await O(x.default.resolve(d),r,s);s||console.log(JSON.stringify(l,null,o?4:0)),e?(m.default.writeFileSync(e,JSON.stringify(l,null,o?4:0)),s||console.log(`Results is written to ${e}`)):console.log(JSON.stringify(l,null,o?4:0));let c=JSON.parse(m.default.readFileSync(`${e}`,"utf-8")),g="output";m.default.existsSync(g)||m.default.mkdirSync(g);for(let d in c){let i=`output/${d.replace(/[/.]/g,"_")}.txt`;m.default.writeFileSync(i,"");let w=c[d].words;for(let f of w){let u=`${f.value}	${f.start}	${f.end}`,h=JSON.stringify(u);m.default.appendFileSync(i,JSON.parse(h)),m.default.appendFileSync(i,`
`)}}});b.program.parse();
