#!/usr/bin/env node
"use strict";var V=Object.create;var b=Object.defineProperty;var B=Object.getOwnPropertyDescriptor;var C=Object.getOwnPropertyNames;var I=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty;var q=(t,o,e,n)=>{if(o&&typeof o=="object"||typeof o=="function")for(let r of C(o))!T.call(t,r)&&r!==e&&b(t,r,{get:()=>o[r],enumerable:!(n=B(o,r))||n.enumerable});return t};var i=(t,o,e)=>(e=t!=null?V(I(t)):{},q(o||!t||!t.__esModule?b(e,"default",{value:t,enumerable:!0}):e,t));var a=i(require("fs")),y=i(require("path")),S=require("commander");var O=i(require("fs")),J=i(require("path")),N=require("stream"),v=i(require("vosk-lib")),L=i(require("wav")),z=i(require("fuse.js")),D=require("opencc");var R=i(require("path")),_=R.default.resolve(__dirname,"..","model"),$=process.env.VERBOSE;var E=i(require("os")),u=i(require("path")),M=require("child_process");function P(t,o="ffmpeg"){let e=u.default.resolve(E.default.tmpdir(),`${u.default.basename(t)}.wav`),n=["-loglevel","error","-i",u.default.basename(t),"-af","agate=range=0:ratio=100:threshold=0.01, dynaudnorm=p=0.5:m=100:s=12:g=15, loudnorm=I=-10:LRA=11:TP=-1","-acodec","pcm_s16le","-ac","1","-ar","16000",e];return(0,M.spawnSync)(o,n,{cwd:u.default.dirname(t),stdio:$?"inherit":"ignore"}),e}var F=!1,j,k=new D.OpenCC("s2t.json");function W(t,o,e){return F===!1&&(e||console.log("Loading model ..."),v.default.setLogLevel(-1),j=new v.default.Model(_),F=!0,e||console.log("Model loaded.")),t=P(J.default.resolve(t)),new Promise(n=>{e||console.log(`Recognizing ${t} ...`);let r=O.default.createReadStream(t,{highWaterMark:8192}),s=new L.default.Reader,f=new N.Readable().wrap(s);s.on("format",async({audioFormat:w,sampleRate:h,channels:c})=>{if(w!=1||c!=1)throw new Error("Audio file must be WAV with mono PCM.");let m=new v.default.Recognizer({model:j,sampleRate:h});m.setMaxAlternatives(3),m.setWords(!0),m.setPartialWords(!0);let p=[];for await(let l of f)if(m.acceptWaveform(l)){let g=await G(m.result(),o);p.push(g),console.log(g),o&&(o=o.slice(g.text.length))}let x={text:p.map(l=>l.text).join(""),words:p.map(l=>l.result.map(d=>({start:d.start,end:d.end,value:d.word}))).flat()};e||console.log(`Recognized ${t}`),r.close(()=>{n(x),O.default.rmSync(t)}),m.free()}),r.pipe(s)})}async function G(t,o){let{alternatives:e}=t;for(let n=0;n<e.length;n++){e[n].text=await k.convertPromise(e[n].text.replace(/\s+/g,""));for(let r=0;r<e[n].result.length;r++)e[n].result[r].word=await k.convertPromise(e[n].result[r].word);delete e[n].confidence}if(o){let r=new z.default(e,{keys:["text"],threshold:1}).search(o);return r.length>0?r.map(s=>s.item)[0]:{result:[],text:""}}else return e[0]}var A=JSON.parse(a.default.readFileSync(y.default.join(__dirname,"..","package.json"),"utf8"));S.program.version(`${A.name} ${A.version}`);S.program.argument("<wav...>","Path to the wav file").option("-e, --expect <expected result>","The expected result").option("-o, --output <path>","The output path").option("-f, --force","Force to overwrite the output file if it exists").option("-p, --pretty","Pretty print the result with indentation").option("-s, --silent","Silent mode").action(async(t,{expect:o,output:e,force:n,pretty:r,silent:s})=>{e&&(e=y.default.resolve(e),a.default.existsSync(e)&&!n&&(s||console.error(`${e} already exists.`),process.exit(1)));let f={};for(let c of t)f[c]=await W(y.default.resolve(c),o,s);s||console.log(JSON.stringify(f,null,r?4:0)),e?(a.default.writeFileSync(e,JSON.stringify(f,null,r?4:0)),s||console.log(`Results is written to ${e}`)):console.log(JSON.stringify(f,null,r?4:0));let w=JSON.parse(a.default.readFileSync(`${e}`,"utf-8")),h="output";a.default.existsSync(h)||a.default.mkdirSync(h);for(let c in w){let p=`output/${c.replace(/[/.]/g,"_")}.txt`;a.default.writeFileSync(p,"");let x=w[c].words;for(let l of x){let d=`${l.value}	${l.start}	${l.end}`,g=JSON.stringify(d);a.default.appendFileSync(p,JSON.parse(g)),a.default.appendFileSync(p,`
`)}}});S.program.parse();
