#!/usr/bin/env node
"use strict";var B=Object.create;var R=Object.defineProperty;var C=Object.getOwnPropertyDescriptor;var I=Object.getOwnPropertyNames;var T=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var G=(o,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of I(t))!q.call(o,r)&&r!==e&&R(o,r,{get:()=>t[r],enumerable:!(n=C(t,r))||n.enumerable});return o};var a=(o,t,e)=>(e=o!=null?B(T(o)):{},G(t||!o||!o.__esModule?R(e,"default",{value:o,enumerable:!0}):e,o));var l=a(require("fs")),y=a(require("path")),S=require("commander");var O=a(require("fs")),N=a(require("path")),L=require("stream"),v=a(require("vosk-lib")),z=a(require("wav")),D=a(require("fuse.js")),W=require("opencc");var b=a(require("path")),_=b.default.resolve(__dirname,"..","model"),$=process.env.VERBOSE;var E=a(require("os")),g=a(require("path")),M=require("child_process");function P(o,t="ffmpeg"){let e=g.default.resolve(E.default.tmpdir(),`${g.default.basename(o)}.wav`),n=["-loglevel","error","-i",g.default.basename(o),"-af","agate=range=0:ratio=100:threshold=0.01, dynaudnorm=p=0.5:m=100:s=12:g=15, loudnorm=I=-10:LRA=11:TP=-1","-acodec","pcm_s16le","-ac","1","-ar","16000",e];return(0,M.spawnSync)(t,n,{cwd:g.default.dirname(o),stdio:$?"inherit":"ignore"}),e}var F=!1,j,k=new W.OpenCC("s2t.json");function A(o,t,e){return F===!1&&(e||console.log("Loading model ..."),v.default.setLogLevel(-1),j=new v.default.Model(_),F=!0,e||console.log("Model loaded.")),o=P(N.default.resolve(o)),new Promise(n=>{e||console.log(`Recognizing ${o} ...`);let r=O.default.createReadStream(o,{highWaterMark:4096}),s=new z.default.Reader,p=new L.Readable().wrap(s);s.on("format",async({audioFormat:u,sampleRate:w,channels:f})=>{if(u!=1||f!=1)throw new Error("Audio file must be WAV with mono PCM.");let m=new v.default.Recognizer({model:j,sampleRate:w});m.setMaxAlternatives(3),m.setWords(!0),m.setPartialWords(!0);let i=[];for await(let c of p)if(m.acceptWaveform(c)){let h=await J(m.result(),t);i.push(h),t&&(t=t.slice(h.text.length))}console.log(i),i.push(await J(m.finalResult(),t)),console.log(i);let x={text:i.map(c=>c.text).join(""),words:i.map(c=>c.result.map(d=>({start:d.start,end:d.end,value:d.word}))).flat()};e||console.log(`Recognized ${o}`),r.close(()=>{n(x),O.default.rmSync(o)}),m.free()}),r.pipe(s)})}async function J(o,t){let{alternatives:e}=o;for(let n=0;n<e.length;n++){e[n].text=await k.convertPromise(e[n].text.replace(/\s+/g,""));for(let r=0;r<e[n].result.length;r++)e[n].result[r].word=await k.convertPromise(e[n].result[r].word);delete e[n].confidence}if(t){let r=new D.default(e,{keys:["text"],threshold:1}).search(t);return r.length>0?r.map(s=>s.item)[0]:{result:[],text:""}}else return e[0]}var V=JSON.parse(l.default.readFileSync(y.default.join(__dirname,"..","package.json"),"utf8"));S.program.version(`${V.name} ${V.version}`);S.program.argument("<wav...>","Path to the wav file").option("-e, --expect <expected result>","The expected result").option("-o, --output <path>","The output path").option("-f, --force","Force to overwrite the output file if it exists").option("-p, --pretty","Pretty print the result with indentation").option("-s, --silent","Silent mode").action(async(o,{expect:t,output:e,force:n,pretty:r,silent:s})=>{e&&(e=y.default.resolve(e),l.default.existsSync(e)&&!n&&(s||console.error(`${e} already exists.`),process.exit(1)));let p={};for(let f of o)p[f]=await A(y.default.resolve(f),t,s);s||console.log(JSON.stringify(p,null,r?4:0)),e?(l.default.writeFileSync(e,JSON.stringify(p,null,r?4:0)),s||console.log(`Results is written to ${e}`)):console.log(JSON.stringify(p,null,r?4:0));let u=JSON.parse(l.default.readFileSync(`${e}`,"utf-8")),w="output";l.default.existsSync(w)||l.default.mkdirSync(w);for(let f in u){let i=`output/${f.replace(/[/.]/g,"_")}.txt`;l.default.writeFileSync(i,"");let x=u[f].words;for(let c of x){let d=`${c.value}	${c.start}	${c.end}`,h=JSON.stringify(d);l.default.appendFileSync(i,JSON.parse(h)),l.default.appendFileSync(i,`
`)}}});S.program.parse();
